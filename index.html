<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Editor for HTML, CSS & JS</title>
<meta name="description" content="Minimalist Code Editor tailored for single-file projects consisting of HTML, CSS and JavaScript.">
<meta name="author" content="Johnny Heggelund">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://morepcfun.github.io/coder/">
<link rel="icon" href="data:image/png;base64,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">
<style>
:root {
--bg-color: #0d1117;
--text-color: #c9d1d9;
--accent-color: #61afef;
--border-color: #282c34;
--caret-color: #61afef;
--selection-bg: rgba(97, 175, 239, 0.3);
--font-mono: 'Fira Code', 'JetBrains Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
--font-size: 15px;
}
html, body {
margin: 0;
padding: 0;
width: 100%;
height: 100%;
background-color: var(--bg-color);
color: var(--text-color);
font-family: var(--font-mono);
overflow: hidden;
}
.editor-container {
display: flex;
height: 100vh;
width: 100vw;
}
#line-numbers {
width: 50px;
padding: 15px 5px 15px 15px;
box-sizing: border-box;
text-align: right;
color: var(--border-color);
user-select: none;
pointer-events: none;
overflow: hidden;
font-size: var(--font-size);
line-height: 1.5;
background-color: var(--bg-color);
white-space: pre;
transition: width 0.2s ease, padding 0.2s ease;
}
.line-numbers-hidden #line-numbers {
width: 0;
padding: 15px 0;
overflow: hidden;
}
textarea#editor {
flex-grow: 1;
height: 100%;
box-sizing: border-box;
border: none;
outline: none;
resize: none;
white-space: pre;
overflow-wrap: normal;
overflow: auto;
background-color: transparent;
color: var(--text-color);
font-family: var(--font-mono);
font-size: var(--font-size);
padding: 15px;
caret-color: var(--caret-color);
line-height: 1.5;
}
textarea::selection {
background-color: var(--selection-bg);
}
.modal {
display: none; position: fixed;
background-color: var(--bg-color); border: 1px solid var(--border-color);
color: var(--text-color); z-index: 100; padding: 20px;
box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
max-height: 80vh;
overflow-y: auto;
}
#help-modal {
top: 50%; left: 50%;
transform: translate(-50%, -50%); width: 450px;
}
#search-modal {
top: 20px;
right: 20px;
width: 350px;
}
.modal h1, .modal h2 {
margin-top: 0; text-align: left; color: var(--accent-color);
font-weight: normal; font-size: 1.2em; border-bottom: 1px solid var(--border-color);
padding-bottom: 10px; margin-bottom: 15px;
}
.modal h2 { font-size: 1em; margin-bottom: 10px; }
.modal ul { list-style-type: none; padding-left: 0; }
.modal li { margin-bottom: 8px; font-size: 0.9em; }
.modal li strong { display: inline-block; width: 160px; color: var(--accent-color); }
.modal-close-btn {
position: absolute; top: 15px; right: 20px; font-size: 24px;
color: var(--border-color); cursor: pointer; background: none;
border: none; transition: color 0.2s;
}
.modal-close-btn:hover { color: var(--text-color); }
#search-modal .input-group { margin-bottom: 15px; }
#search-modal label { display: block; margin-bottom: 5px; font-size: 0.9em; }
#search-modal #match-count { float: right; font-size: 0.9em; color: #888; }
#search-modal input {
width: 100%; background-color: #161b22; border: 1px solid var(--border-color);
color: var(--text-color); padding: 8px; box-sizing: border-box;
font-family: inherit; font-size: 0.9em;
}
#search-modal .button-group { display: flex; justify-content: space-between; gap: 10px; }
#search-modal button {
flex-grow: 1; background-color: #21262d; border: 1px solid var(--border-color);
color: var(--text-color); padding: 8px 12px; cursor: pointer;
transition: background-color 0.2s, border-color 0.2s;
}
#search-modal button:hover { background-color: #30363d; border-color: var(--accent-color); }
#toast-notification {
position: fixed;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
background-color: var(--border-color);
color: var(--text-color);
padding: 10px 20px;
border-radius: 5px;
z-index: 200;
opacity: 0;
visibility: hidden;
transition: opacity 0.4s ease-in-out, visibility 0.4s ease-in-out;
font-size: 0.9em;
}
#toast-notification.show {
opacity: 1;
visibility: visible;
}
</style>
</head>
<body>
<div id="editor-container" class="editor-container"> <div id="line-numbers">1</div>
<textarea id="editor" spellcheck="false"></textarea>
</div>
<div id="help-modal" class="modal">
<button id="help-modal-close-btn" class="modal-close-btn" aria-label="Close">Ã—</button>
<h1 id="help-main-title"></h1>
<h2 id="help-title"></h2>
<ul id="help-list"></ul>
</div>
<div id="search-modal" class="modal">
<div class="input-group">
<label for="find-input">
<span id="find-label-text"></span>
<span id="match-count"></span>
</label>
<input type="text" id="find-input">
</div>
<div class="input-group">
<label for="replace-input" id="replace-label"></label>
<input type="text" id="replace-input">
</div>
<div class="button-group">
<button id="find-next-btn"></button>
<button id="replace-btn"></button>
<button id="replace-all-btn"></button>
</div>
</div>
<div id="toast-notification"></div>
<script>
const CodeEditor = {

config: {
debounceDelay: 100,
indentUnit: '  ',
toastDuration: 2500,
},

state: {
fileHandle: null,
fileName: 'Untitled',
hasUnsavedChanges: false,
searchResults: { term: '', indices: [], currentIndex: -1 },
toastTimer: null,
lastLineCount: 0,
lastMatchPosition: 0,
},

elements: {},
debouncedUpdateLineNumbers: null,

lang: {
title: "Code Editor for HTML, CSS & JS",
untitled: "Untitled",
mainTitle: "Code Editor for HTML CSS JS",
helpTitle: "Shortcuts",
helpOpenFile: "Open File",
helpSaveFile: "Save File",
helpNewFile: "New File",
helpSearchReplace: "Search & Replace",
helpToggleHelp: "Show/Hide Help",
helpCleanWhitespace: "Clean Whitespace",
helpRemoveEmptyLines: "Remove Empty Lines",
helpPreview: "Preview in New Tab",
helpIndent: "Indent",
helpOutdent: "Outdent",
helpNewTab: "Open in New Tab",
helpJumpStyle: "Jump to &lt;style&gt;",
helpJumpScript: "Jump to &lt;script&gt;",
helpJumpBody: "Jump to &lt;body&gt;",
helpToggleLineNumbers: "Toggle Line Numbers",
searchTitle: "Search & Replace",
findLabel: "Find:",
replaceLabel: "Replace with:",
findNext: "Find Next",
replace: "Replace",
replaceAll: "Replace All",
matches: "matches",
unsavedChanges: "You have unsaved changes. Are you sure?",
unsavedChangesLost: "You have unsaved changes that will be lost. Are you sure?",
unsupportedApi: "Your browser does not support the modern File System API.",
userAbortedOpen: "User aborted file opening.",
userAbortedSave: "User aborted the save dialog.",
saveError: "Error: Could not save the file."
},

init() {
this.cacheDOMElements();
this.updateStaticUIText();
this.bindEventListeners();

this.debouncedUpdateLineNumbers = this.utils.debounce(this.updateLineNumbers.bind(this), this.config.debounceDelay);
this.updateLineNumbers();

if (localStorage.getItem('lineNumbersHidden') === 'true') {
this.elements.editorContainer.classList.add('line-numbers-hidden');
}

this.toggleModal('help');
},

cacheDOMElements() {
this.elements = {
editorContainer: document.getElementById('editor-container'),
editor: document.getElementById('editor'),
lineNumbers: document.getElementById('line-numbers'),
helpModal: document.getElementById('help-modal'),
helpModalCloseBtn: document.getElementById('help-modal-close-btn'),
searchModal: document.getElementById('search-modal'),
findInput: document.getElementById('find-input'),
replaceInput: document.getElementById('replace-input'),
findNextBtn: document.getElementById('find-next-btn'),
replaceBtn: document.getElementById('replace-btn'),
replaceAllBtn: document.getElementById('replace-all-btn'),
matchCountSpan: document.getElementById('match-count'),
helpMainTitle: document.getElementById('help-main-title'),
helpTitle: document.getElementById('help-title'),
helpList: document.getElementById('help-list'),
findLabelText: document.getElementById('find-label-text'),
replaceLabel: document.getElementById('replace-label'),
toast: document.getElementById('toast-notification'),
};
},

bindEventListeners() {
const { editor, findInput, helpModalCloseBtn, searchModalCloseBtn, findNextBtn, replaceBtn, replaceAllBtn } = this.elements;

editor.addEventListener('scroll', () => { lineNumbers.scrollTop = editor.scrollTop });
editor.addEventListener('input', this.handleEditorInput.bind(this));
editor.addEventListener('keydown', this.handleEditorKeyDown.bind(this));

findInput.addEventListener('input', this.utils.debounce(this.updateSearchResults.bind(this), this.config.debounceDelay));

helpModalCloseBtn.addEventListener('click', () => this.toggleModal('help'));

findNextBtn.addEventListener('click', this.findNext.bind(this));
replaceBtn.addEventListener('click', this.replaceCurrent.bind(this));
replaceAllBtn.addEventListener('click', this.replaceAll.bind(this));

document.addEventListener('keydown', this.handleGlobalKeyDown.bind(this));
window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
window.addEventListener('focus', () => {
if (this.elements.helpModal.style.display !== 'block' && this.elements.searchModal.style.display !== 'block') {
editor.focus();
}
});
},

toggleModal(modalName) {
const modal = this.elements[`${modalName}Modal`];
const isVisible = modal.style.display === 'block';
modal.style.display = isVisible ? 'none' : 'block';

if (!isVisible) {
if (modalName === 'search') {
this.elements.findInput.focus();
this.elements.findInput.select();
this.updateSearchResults();
}
} else {
this.elements.editor.focus();
}
},

showToast(message) {
clearTimeout(this.state.toastTimer);
this.elements.toast.textContent = message;
this.elements.toast.classList.add('show');
this.state.toastTimer = setTimeout(() => {
this.elements.toast.classList.remove('show');
}, this.config.toastDuration);
},

updateLineNumbers() {
const text = this.elements.editor.value;
const lineCount = (text.match(/\n/g) || []).length + 1;

if (lineCount !== this.state.lastLineCount) {
this.state.lastLineCount = lineCount;
const numbers = Array.from({ length: lineCount }, (_, i) => i + 1).join('\n');
this.elements.lineNumbers.textContent = numbers;
}
},

_safeModifyOutsideScript(regex, replacement) {
const editor = this.elements.editor;
const originalValue = editor.value;
let newValue = '';

const closingScriptTag = '</scr' + 'ipt>';
const scriptTagStart = originalValue.indexOf('<script>');
const scriptTagEnd = originalValue.lastIndexOf(closingScriptTag);

if (scriptTagStart !== -1 && scriptTagEnd !== -1 && scriptTagEnd > scriptTagStart) {
const beforeScript = originalValue.substring(0, scriptTagStart);
const scriptBlock = originalValue.substring(scriptTagStart, scriptTagEnd + closingScriptTag.length);
const afterScript = originalValue.substring(scriptTagEnd + closingScriptTag.length);

const cleanedBefore = beforeScript.replace(regex, replacement);
const cleanedAfter = afterScript.replace(regex, replacement);

newValue = cleanedBefore + scriptBlock + cleanedAfter;
} else {
newValue = originalValue.replace(regex, replacement);
}

if (originalValue !== newValue) {
const originalScrollTop = editor.scrollTop;
editor.value = newValue;
editor.scrollTop = originalScrollTop;
this.setUnsavedChanges(true);
this.updateLineNumbers();

const linesRemoved = (originalValue.match(/\n/g) || []).length - (newValue.match(/\n/g) || []).length;
return linesRemoved;
}
return 0;
},

cleanWhitespace() {
const linesRemoved = this._safeModifyOutsideScript(/^\s*$\r?\n/gm, '');
if (linesRemoved > 0) {
this.showToast(`Removed ${linesRemoved} whitespace line(s) (outside script)`);
}
},

removeEmptyLines() {
const linesRemoved = this._safeModifyOutsideScript(/(\r?\n){2,}/g, '\n');
if (linesRemoved > 0) {
this.showToast(`Removed ${linesRemoved} empty line(s) (outside script)`);
}
},

previewInNewTab() {
const blob = new Blob([this.elements.editor.value], { type: 'text/html' });
const url = URL.createObjectURL(blob);
window.open(url, '_blank');
},

async openFile() {
if (this.state.hasUnsavedChanges && !confirm(this.lang.unsavedChangesLost)) return;
if (!('showOpenFilePicker' in window)) return alert(this.lang.unsupportedApi);

try {
const [fileHandle] = await window.showOpenFilePicker();
this.state.fileHandle = fileHandle;
const file = await fileHandle.getFile();
this.elements.editor.value = await file.text();

this.state.fileName = file.name;
this.setUnsavedChanges(false);
this.updateLineNumbers();
this.elements.editor.scrollTop = 0;
this.elements.editor.setSelectionRange(0, 0);
this.elements.editor.focus();
} catch (err) {
if (err.name !== 'AbortError') console.warn(this.lang.userAbortedOpen, err);
}
},

newFile() {
if (this.state.hasUnsavedChanges && !confirm(this.lang.unsavedChanges)) return;

this.elements.editor.value = '';
this.state.fileHandle = null;
this.state.fileName = this.lang.untitled;
this.setUnsavedChanges(false);
this.updateLineNumbers();
this.elements.editor.focus();
},

async saveFile() {
if (!this.state.fileHandle) {
try {
this.state.fileHandle = await window.showSaveFilePicker({
suggestedName: this.state.fileName.endsWith('.txt') ? this.state.fileName.replace('.txt', '.html') : this.state.fileName,
types: [{
description: 'Web Files',
accept: {
'text/html': ['.html', '.htm'], 'text/css': ['.css'],
'application/javascript': ['.js'], 'text/plain': ['.txt', '.md'],
},
}],
});
this.state.fileName = this.state.fileHandle.name;
} catch (err) {
if (err.name !== 'AbortError') console.warn(this.lang.userAbortedSave, err);
return;
}
}

try {
const writable = await this.state.fileHandle.createWritable();
await writable.write(this.elements.editor.value);
await writable.close();
this.setUnsavedChanges(false);
this.showToast(`Saved to ${this.state.fileName}`);
} catch (err) {
console.error('Could not save file:', err);
alert(this.lang.saveError);
}
},

jumpToSection(tagName) {
const editor = this.elements.editor;
const tag = `<${tagName}`;
const position = editor.value.indexOf(tag);
if (position === -1) return;

editor.focus();
editor.setSelectionRange(position, position);

const textUpToMatch = editor.value.substring(0, position);
const lineNumber = (textUpToMatch.match(/\n/g) || []).length;
const totalLines = (editor.value.match(/\n/g) || []).length + 1;
const avgLineHeight = editor.scrollHeight / totalLines;
const targetScrollTop = lineNumber * avgLineHeight;
const finalScrollTop = targetScrollTop - (editor.clientHeight / 3);

editor.scrollTo({
top: Math.max(0, finalScrollTop),
behavior: 'smooth'
});
},

setUnsavedChanges(isUnsaved) {
this.state.hasUnsavedChanges = isUnsaved;
document.title = isUnsaved ? `* ${this.state.fileName}` : this.state.fileName;
},

updateSearchResults() {
const searchTerm = this.elements.findInput.value;
this.elements.matchCountSpan.textContent = '';

if (!searchTerm) {
this.state.searchResults = { term: '', indices: [], currentIndex: -1 };
return;
}

if (this.state.searchResults.term.toLowerCase() === searchTerm.toLowerCase()) return;

this.state.searchResults = {
term: searchTerm,
indices: [],
currentIndex: -1
};

const escapedTerm = this.utils.escapeRegExp(searchTerm);
const regex = new RegExp(escapedTerm, 'gi');
let match;
while ((match = regex.exec(this.elements.editor.value)) !== null) {
this.state.searchResults.indices.push(match.index);
}

if (this.state.searchResults.indices.length > 0) {
this.elements.matchCountSpan.textContent = `${this.state.searchResults.indices.length} ${this.lang.matches}`;
}

if (this.state.lastMatchPosition > 0) {
const nextIndex = this.state.searchResults.indices.findIndex(index => index >= this.state.lastMatchPosition);
if (nextIndex !== -1) {
this.state.searchResults.currentIndex = nextIndex - 1;
}
}
},

findNext() {
this.updateSearchResults();
const { indices, term } = this.state.searchResults;
if (indices.length === 0) return;

this.state.searchResults.currentIndex = (this.state.searchResults.currentIndex + 1) % indices.length;
const startIndex = indices[this.state.searchResults.currentIndex];
this.state.lastMatchPosition = startIndex;
const editor = this.elements.editor;

editor.focus();
editor.setSelectionRange(startIndex, startIndex + term.length);

const textUpToMatch = editor.value.substring(0, startIndex);
const lineNumber = (textUpToMatch.match(/\n/g) || []).length;
const totalLines = (editor.value.match(/\n/g) || []).length + 1;
const avgLineHeight = editor.scrollHeight / totalLines;
const targetScrollTop = lineNumber * avgLineHeight;
const finalScrollTop = targetScrollTop - (editor.clientHeight / 2) + (avgLineHeight / 2);

editor.scrollTo({
top: Math.max(0, finalScrollTop),
behavior: 'smooth'
});
},

replaceCurrent() {
const { term } = this.state.searchResults;
const replaceTerm = this.elements.replaceInput.value;
const { selectionStart, selectionEnd } = this.elements.editor;

if (!term || selectionStart === selectionEnd) {
this.findNext();
return;
}

const selectedText = this.elements.editor.value.substring(selectionStart, selectionEnd);
if (selectedText.toLowerCase() === term.toLowerCase()) {
this.elements.editor.setRangeText(replaceTerm, selectionStart, selectionEnd, 'end');
this.setUnsavedChanges(true);
this.state.searchResults.term = null;
}
this.findNext();
},

replaceAll() {
const term = this.elements.findInput.value;
const replaceTerm = this.elements.replaceInput.value;
if (!term) return;

const originalValue = this.elements.editor.value;
const newValue = originalValue.replace(new RegExp(this.utils.escapeRegExp(term), 'gi'), replaceTerm);

if (originalValue !== newValue) {
const originalScrollTop = this.elements.editor.scrollTop;
this.elements.editor.value = newValue;
this.elements.editor.scrollTop = originalScrollTop;
this.setUnsavedChanges(true);
this.updateSearchResults();
}
},

handleEditorInput() {
if (!this.state.hasUnsavedChanges) {
this.setUnsavedChanges(true);
}
this.state.searchResults.term = '';
this.debouncedUpdateLineNumbers();
},

handleEditorKeyDown(e) {
if (e.key === 'Tab') {
e.preventDefault();
const { selectionStart, selectionEnd, value } = this.elements.editor;
const indent = this.config.indentUnit;

if (selectionStart !== selectionEnd && value.substring(selectionStart, selectionEnd).includes('\n')) {
let lineStart = value.lastIndexOf('\n', selectionStart - 1) + 1;
const affectedText = value.substring(lineStart, selectionEnd);
let newText;

if (e.shiftKey) {
newText = affectedText.split('\n').map(line =>
line.startsWith(indent) ? line.substring(indent.length) : line
).join('\n');
} else {
newText = affectedText.split('\n').map(line => indent + line).join('\n');
}
this.elements.editor.setRangeText(newText, lineStart, selectionEnd, 'select');
} else {
if (!e.shiftKey) {
this.elements.editor.setRangeText(indent, selectionStart, selectionEnd, 'end');
}
}
this.setUnsavedChanges(true);
this.updateLineNumbers();
}
},

handleGlobalKeyDown(e) {
const isModalOpen = this.elements.helpModal.style.display === 'block' || this.elements.searchModal.style.display === 'block';
const isCtrl = e.ctrlKey || e.metaKey;
const key = e.key.toLowerCase();
if (key === 's') { e.preventDefault(); this.saveFile(); }
if (e.altKey && key === 'h') { e.preventDefault(); this.toggleModal('help'); }
if (e.altKey && key === 'f') { e.preventDefault(); this.toggleModal('search'); }

if (isModalOpen) {
if (key === 'escape') {
e.preventDefault();
if (this.elements.searchModal.style.display === 'block') this.toggleModal('search');
if (this.elements.helpModal.style.display === 'block') this.toggleModal('help');
}
return;
}

if (isCtrl) {
if (key === 'o') { e.preventDefault(); this.openFile(); }
if (e.shiftKey) {
if (e.code === 'Digit1') { e.preventDefault(); this.jumpToSection('style'); }
if (e.code === 'Digit2') { e.preventDefault(); this.jumpToSection('script'); }
if (e.code === 'Digit3') { e.preventDefault(); this.jumpToSection('body'); }
}
} else if (e.altKey) {
if (key === 'n') { e.preventDefault(); this.newFile(); }
if (key === 'w') { e.preventDefault(); this.cleanWhitespace(); }
if (key === 'l') { e.preventDefault(); this.removeEmptyLines(); }
if (key === 'p') { e.preventDefault(); this.previewInNewTab(); }
if (key === 't') { e.preventDefault(); window.open(window.location.href, '_blank'); }
if (key === 'i') { e.preventDefault(); this.toggleLineNumbers(); }
}
},

handleBeforeUnload(e) {
if (this.state.hasUnsavedChanges) {
e.preventDefault();
e.returnValue = '';
}
},

toggleLineNumbers() {
const container = this.elements.editorContainer;
container.classList.toggle('line-numbers-hidden');
localStorage.setItem('lineNumbersHidden', container.classList.contains('line-numbers-hidden'));
},

updateStaticUIText() {
document.title = this.lang.title;
const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();

const shortcuts = [
{ key: 'Ctrl + O', action: this.lang.helpOpenFile },
{ key: 'Ctrl + S', action: this.lang.helpSaveFile },
{ key: 'Alt + N', action: this.lang.helpNewFile },
{ isSeparator: true },
{ key: 'Alt + F', action: this.lang.helpSearchReplace },
{ key: 'Alt + P', action: this.lang.helpPreview },
{ key: 'Alt + H', action: this.lang.helpToggleHelp },
{ key: 'Alt + I', action: this.lang.helpToggleLineNumbers },
{ isSeparator: true },
{ key: 'Alt + W', action: this.lang.helpCleanWhitespace },
{ key: 'Alt + L', action: this.lang.helpRemoveEmptyLines },
{ isSeparator: true },
{ key: 'Ctrl + Shift + 1', action: this.lang.helpJumpStyle },
{ key: 'Ctrl + Shift + 2', action: this.lang.helpJumpScript },
{ key: 'Ctrl + Shift + 3', action: this.lang.helpJumpBody },
{ isSeparator: true },
{ key: 'Alt + T', action: this.lang.helpNewTab },
{ key: 'Tab', action: this.lang.helpIndent },
{ key: 'Shift + Tab', action: this.lang.helpOutdent },
];

this.elements.helpList.innerHTML = shortcuts.map(item => {
if (item.isSeparator) return `<hr style="border-color: ${borderColor}; margin: 10px 0;">`;
return `<li><strong>${item.key}</strong> ${item.action}</li>`;
}).join('');

this.elements.helpMainTitle.textContent = this.lang.mainTitle;
this.elements.helpTitle.textContent = this.lang.helpTitle;
this.elements.findLabelText.textContent = this.lang.findLabel;
this.elements.replaceLabel.textContent = this.lang.replaceLabel;
this.elements.findNextBtn.textContent = this.lang.findNext;
this.elements.replaceBtn.textContent = this.lang.replace;
this.elements.replaceAllBtn.textContent = this.lang.replaceAll;
},

utils: {
debounce(func, delay) {
let timeout;
return function(...args) {
clearTimeout(timeout);
timeout = setTimeout(() => func.apply(this, args), delay);
};
},
escapeRegExp(string) {
return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
}
};

window.addEventListener('load', () => CodeEditor.init());

</script></body>
</html>