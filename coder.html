<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Editor 2 Online (HTML CSS & Javascript)</title>
<meta name="description" content="A web-based code editor, designed for small to medium-sized web projects. Includes live webpage previews, an advanced search function, and much more.">
<meta name="author" content="Johnny Heggelund">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
html,
body {
margin: 0;
padding: 0;
width: 100%;
height: 100%;
background-color: #000000;
overflow: hidden;
}
textarea {
width: 100%;
height: 100%;
box-sizing: border-box;
border: none;
outline: none;
resize: none;
white-space: pre;
overflow-wrap: normal;
overflow: auto;
background-color: #000000;
color: #33FF33;
font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
font-size: 16px;
padding: 15px;
caret-color: #33FF33;
caret-shape: block;
}
.modal {
display: none;
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 400px;
background-color: #000;
border: 2px solid #33FF33;
color: #33FF33;
z-index: 100;
font-family: inherit;
padding: 20px;
box-shadow: 0 0 20px rgba(51, 255, 51, 0.3);
}
.modal h2 {
margin-top: 0;
text-align: left;
}
.modal ul {
list-style-type: none;
padding-left: 0;
}
.modal li {
margin-bottom: 10px;
}
.modal li strong {
display: inline-block;
width: 120px;
}
.modal-close-btn {
position: absolute;
top: 10px;
right: 15px;
font-size: 24px;
color: #33FF33;
cursor: pointer;
background: none;
border: none;
}
#search-modal .input-group {
margin-bottom: 15px;
}
#search-modal label {
display: block;
margin-bottom: 5px;
}
#search-modal #match-count {
float: right;
font-size: 0.8em;
color: #aaa;
line-height: 1.5;
}
#search-modal input {
width: 100%;
background-color: #111;
border: 1px solid #33FF33;
color: #33FF33;
padding: 5px;
box-sizing: border-box;
font-family: inherit;
}
#search-modal .button-group {
display: flex;
justify-content: space-between;
gap: 10px;
}
#search-modal button {
flex-grow: 1;
background: none;
border: 1px solid #33FF33;
color: #33FF33;
padding: 8px;
cursor: pointer;
transition: background-color 0.2s, color 0.2s;
}
#search-modal button:hover {
background-color: #33FF33;
color: #000;
}
</style>
</head>
<body>
<textarea id="editor" spellcheck="false" autofocus></textarea>
<div id="help-modal" class="modal">
<button id="help-modal-close-btn" class="modal-close-btn">&times;</button>
<h1>Online Code Editor</h1>
<h2 id="help-title"></h2>
<ul id="help-list"></ul>
</div>
<div id="search-modal" class="modal">
<button id="search-modal-close-btn" class="modal-close-btn">&times;</button>
<h1>Code Editor Online</h1>
<h2 id="search-title"></h2>
<div class="input-group">
<label for="find-input" id="find-label"><span id="match-count"></span></label>
<input type="text" id="find-input">
</div>
<div class="input-group">
<label for="replace-input" id="replace-label"></label>
<input type="text" id="replace-input">
</div>
<div class="button-group">
<button id="find-next-btn"></button>
<button id="replace-btn"></button>
<button id="replace-all-btn"></button>
</div>
</div>
<script>
const lang = {
title: "Code Editor",
untitled: "Untitled.txt",
helpTitle: "Shortcuts",
helpOpenFile: "Open File",
helpSaveFile: "Save File",
helpNewFile: "New File",
helpSearchReplace: "Search & Replace",
helpToggleHelp: "Toggle Help",
helpIndent: "Indent (Add Spaces)",
helpOutdent: "Outdent (Remove Spaces)",
helpCleanLines: "Clean Lines & Whitespace",
helpNewTab: "Open in New Tab",
helpPreview: "Preview HTML",
searchTitle: "Search & Replace",
findLabel: "Find:",
replaceLabel: "Replace:",
findNext: "Find Next",
replace: "Replace",
replaceAll: "Replace All",
matches: "matches",
unsavedChanges: "You have unsaved changes. Are you sure?",
unsavedChangesLost: "You have unsaved changes that will be lost. Are you sure?",
unsupportedApi: "Your browser doesn't support the modern File System API.",
userAbortedOpen: "User aborted file open.",
userAbortedSave: "User aborted the save dialog.",
saveError: "Error: Unable to save the file."
};
document.title = lang.title;
const editor = document.getElementById('editor');
const helpModal = document.getElementById('help-modal');
const helpModalCloseBtn = document.getElementById('help-modal-close-btn');
const searchModal = document.getElementById('search-modal');
const searchModalCloseBtn = document.getElementById('search-modal-close-btn');
const findInput = document.getElementById('find-input');
const replaceInput = document.getElementById('replace-input');
const findNextBtn = document.getElementById('find-next-btn');
const replaceBtn = document.getElementById('replace-btn');
const replaceAllBtn = document.getElementById('replace-all-btn');
const matchCountSpan = document.getElementById('match-count');
let currentFileHandle = null;
let currentFileName = lang.untitled;
let hasUnsavedChanges = false;
let searchResults = { term: '', indices: [], currentIndex: -1 };
const mirrorDiv = document.createElement('div');
document.body.appendChild(mirrorDiv);
function syncMirrorStyles() {
const editorStyle = window.getComputedStyle(editor);
const propertiesToCopy = [
'fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'letterSpacing',
'lineHeight', 'textTransform', 'wordSpacing', 'paddingTop', 'paddingRight',
'paddingBottom', 'paddingLeft', 'borderTopWidth', 'borderRightWidth',
'borderBottomWidth', 'borderLeftWidth', 'width', 'boxSizing',
'whiteSpace', 'overflowWrap'
];
propertiesToCopy.forEach(prop => {
mirrorDiv.style[prop] = editorStyle[prop];
});
mirrorDiv.style.position = 'absolute';
mirrorDiv.style.left = '-9999px';
mirrorDiv.style.top = '0';
mirrorDiv.style.height = 'auto';
mirrorDiv.style.visibility = 'hidden';
}
async function openFile() {
if (hasUnsavedChanges && !confirm(lang.unsavedChangesLost)) {
return;
}
if ('showOpenFilePicker' in window) {
try {
const [fileHandle] = await window.showOpenFilePicker();
currentFileHandle = fileHandle;
const file = await fileHandle.getFile();
editor.value = await file.text();
editor.scrollTop = 0;
editor.setSelectionRange(0, 0);
currentFileName = file.name;
document.title = currentFileName;
hasUnsavedChanges = false;
} catch (err) { console.error(lang.userAbortedOpen, err); }
} else {
alert(lang.unsupportedApi);
}
}
function newFile() {
if (hasUnsavedChanges && !confirm(lang.unsavedChanges)) {
return;
}
editor.value = '';
currentFileHandle = null;
currentFileName = lang.untitled;
document.title = currentFileName;
hasUnsavedChanges = false;
editor.focus();
}
async function saveFile() {
if (!currentFileHandle) {
try {
currentFileHandle = await window.showSaveFilePicker({
suggestedName: currentFileName,
types: [{
description: 'Text/Code Files',
accept: {
'text/plain': ['.txt', '.md'],
'text/html': ['.html', '.htm'],
'text/css': ['.css'],
'application/javascript': ['.js']
},
}],
});
currentFileName = currentFileHandle.name;
} catch (err) { console.error(lang.userAbortedSave, err); return; }
}
try {
const writable = await currentFileHandle.createWritable();
await writable.write(editor.value);
await writable.close();
hasUnsavedChanges = false;
document.title = currentFileName;
} catch (err) { console.error('Failed to save file:', err); alert(lang.saveError); }
}
function previewCode() {
const previewWindow = window.open('', '_blank');
previewWindow.document.open();
previewWindow.document.write(editor.value);
previewWindow.document.close();
}
function outdentSelection() {
const start = editor.selectionStart;
const end = editor.selectionEnd;
let lineStart = start;
while (lineStart > 0 && editor.value[lineStart - 1] !== '\n') lineStart--;
const textBefore = editor.value.substring(0, lineStart);
let textToModify = editor.value.substring(lineStart, end);
let removedCharsCount = 0;
const outdentedText = textToModify.split('\n').map(line => {
if (line.startsWith('  ')) {
removedCharsCount += 2;
return line.substring(2);
} else if (line.startsWith(' ')) {
removedCharsCount += 1;
return line.substring(1);
}
return line;
}).join('\n');
editor.value = textBefore + outdentedText + editor.value.substring(end);
const firstLine = textToModify.split('\n')[0];
let firstLineRemovedChars = 0;
if (firstLine.startsWith('  ')) {
firstLineRemovedChars = 2;
} else if (firstLine.startsWith(' ')) {
firstLineRemovedChars = 1;
}
editor.selectionStart = start - firstLineRemovedChars;
editor.selectionEnd = end - removedCharsCount;
}
function cleanEmptyLines() {
const { selectionStart, selectionEnd } = editor;
const isSelection = selectionStart !== selectionEnd;
const text = isSelection ? editor.value.substring(selectionStart, selectionEnd) : editor.value;
const cleaned = text.split('\n').map(l => l.trimEnd()).filter(l => l !== '').join('\n');
if (isSelection) editor.setRangeText(cleaned, selectionStart, selectionEnd);
else editor.value = cleaned;
}
function toggleHelp() {
const isVisible = helpModal.style.display === 'block';
helpModal.style.display = isVisible ? 'none' : 'block';
if (isVisible) editor.focus();
}
function toggleSearch() {
const isVisible = searchModal.style.display === 'block';
searchModal.style.display = isVisible ? 'none' : 'block';
if (!isVisible) {
findInput.focus();
findInput.select();
updateSearchResults();
} else {
editor.focus();
}
}
function updateSearchResults() {
const searchTerm = findInput.value;
if (searchResults.term === searchTerm && searchTerm !== '') return;
searchResults.term = searchTerm;
searchResults.indices = [];
searchResults.currentIndex = -1;
if (!searchTerm) {
matchCountSpan.textContent = '';
return;
}
let fromIndex = 0;
while (fromIndex < editor.value.length) {
const foundIndex = editor.value.toLowerCase().indexOf(searchTerm.toLowerCase(), fromIndex);
if (foundIndex === -1) break;
searchResults.indices.push(foundIndex);
fromIndex = foundIndex + 1;
}
matchCountSpan.textContent = `${searchResults.indices.length} ${lang.matches}`;
}
function scrollToSelection() {
const textBefore = editor.value.substring(0, editor.selectionStart);
mirrorDiv.innerText = textBefore;
const marker = document.createElement('span');
marker.innerHTML = '&nbsp;';
mirrorDiv.appendChild(marker);
const selectionYPosition = marker.offsetTop;
const targetScrollTop = selectionYPosition - (editor.clientHeight / 2);
editor.scrollTop = Math.max(0, targetScrollTop);
}
function findNext() {
updateSearchResults();
if (searchResults.indices.length === 0) {
matchCountSpan.textContent = `0 ${lang.matches}`;
return;
}
searchResults.currentIndex++;
if (searchResults.currentIndex >= searchResults.indices.length) {
searchResults.currentIndex = 0;
}
const startIndex = searchResults.indices[searchResults.currentIndex];
editor.focus();
editor.setSelectionRange(startIndex, startIndex + searchResults.term.length);
matchCountSpan.textContent = `${searchResults.currentIndex + 1} of ${searchResults.indices.length}`;
scrollToSelection();
}
function replaceCurrent() {
const searchTerm = findInput.value;
const replaceTerm = replaceInput.value;
const selectedText = editor.value.substring(editor.selectionStart, editor.selectionEnd);
if (searchTerm && selectedText.toLowerCase() === searchTerm.toLowerCase()) {
const start = editor.selectionStart;
editor.setRangeText(replaceTerm, start, editor.selectionEnd, 'end');
updateSearchResults();
let searchFrom = start + replaceTerm.length;
let nextIndex = editor.value.toLowerCase().indexOf(searchTerm.toLowerCase(), searchFrom);
if (nextIndex !== -1) {
searchResults.currentIndex = searchResults.indices.findIndex(i => i >= nextIndex);
findNext();
}
} else {
findNext();
}
}
function replaceAll() {
const searchTerm = findInput.value;
const replaceTerm = replaceInput.value;
if (!searchTerm) return;
const originalScrollTop = editor.scrollTop;
const regex = new RegExp(searchTerm, 'gi');
editor.value = editor.value.replace(regex, replaceTerm);
editor.scrollTop = originalScrollTop;
updateSearchResults();
}
function updateStaticUIText() {
document.getElementById('help-title').textContent = lang.helpTitle;
document.getElementById('help-list').innerHTML = `
<li><strong>Ctrl + O</strong> ${lang.helpOpenFile}</li>
<li><strong>Ctrl + S</strong> ${lang.helpSaveFile}</li>
<li><strong>Alt + N</strong> ${lang.helpNewFile}</li>
<li><strong>Alt + S</strong> ${lang.helpSearchReplace}</li>
<li><strong>Ctrl + H</strong> ${lang.helpToggleHelp}</li>
<li><strong>Tab</strong> ${lang.helpIndent}</li>
<li><strong>Shift + Tab</strong> ${lang.helpOutdent}</li>
<li><strong>Alt + L</strong> ${lang.helpCleanLines}</li>
<li><strong>Alt + T</strong> ${lang.helpNewTab}</li>
<li><strong>Alt + P</strong> ${lang.helpPreview}</li>
`;
document.getElementById('search-title').textContent = lang.searchTitle;
document.getElementById('find-label').prepend(lang.findLabel);
document.getElementById('replace-label').textContent = lang.replaceLabel;
document.getElementById('find-next-btn').textContent = lang.findNext;
document.getElementById('replace-btn').textContent = lang.replace;
document.getElementById('replace-all-btn').textContent = lang.replaceAll;
}
findInput.addEventListener('input', updateSearchResults);
helpModalCloseBtn.addEventListener('click', toggleHelp);
searchModalCloseBtn.addEventListener('click', toggleSearch);
findNextBtn.addEventListener('click', findNext);
replaceBtn.addEventListener('click', replaceCurrent);
replaceAllBtn.addEventListener('click', replaceAll);
window.addEventListener('click', (e) => { if (e.target.tagName === 'BODY') editor.focus(); });
editor.addEventListener('keydown', function(e) {
const start = this.selectionStart;
const end = this.selectionEnd;
if (!e.ctrlKey && !e.altKey) {
const key = e.key;
if (key === '{') {
e.preventDefault();
const textToInsert = '{\n  \n}';
this.setRangeText(textToInsert, start, end, 'end');
const newCursorPos = this.selectionStart - 2;
this.setSelectionRange(newCursorPos, newCursorPos);
return;
}
const bracketMap = { '(': ')', '[': ']' };
if (bracketMap[key]) {
e.preventDefault();
const textToInsert = key + bracketMap[key];
this.setRangeText(textToInsert, start, end, 'end');
const newCursorPos = this.selectionStart - 1;
this.setSelectionRange(newCursorPos, newCursorPos);
return;
}
if (key === '/') {
if (this.value.substring(start - 1, start) === '<') {
const textBefore = this.value.substring(0, start - 1);
const openTags = (textBefore.match(/<([a-zA-Z0-9]+)/g) || []).map(tag => tag.substring(1));
const closeTags = (textBefore.match(/<\/([a-zA-Z0-9]+)>/g) || []).map(tag => tag.substring(2, tag.length - 1));
const stack = [];
const selfClosingTags = new Set(['br', 'hr', 'img', 'input', 'meta', 'link']);
for (const tag of openTags) {
if (!selfClosingTags.has(tag)) stack.push(tag);
}
for (const tag of closeTags) {
if (stack.length > 0 && stack[stack.length - 1] === tag) stack.pop();
}
if (stack.length > 0) {
const tagToClose = stack.pop();
e.preventDefault();
this.setRangeText(`${tagToClose}>`, start, end, 'end');
return;
}
}
}
if (key === '>') {
const textBefore = this.value.substring(0, start);
const tagMatch = textBefore.match(/<([a-zA-Z0-9]+)[^>]*$/);
const selfClosingTags = new Set(['br', 'hr', 'img', 'input', 'meta', 'link']);
if (tagMatch && !textBefore.endsWith('/') && !selfClosingTags.has(tagMatch[1])) {
const tagName = tagMatch[1];
const closingTag = `</${tagName}>`;
const textToInsert = `>${closingTag}`;
e.preventDefault();
this.setRangeText(textToInsert, start, end, 'end');
const newCursorPos = this.selectionStart - closingTag.length;
this.setSelectionRange(newCursorPos, newCursorPos);
return;
}
}
}
if (e.key === 'Tab') {
e.preventDefault();
if (e.shiftKey) {
outdentSelection();
} else {
const selected = this.value.substring(start, end);
if (selected.includes('\n')) {
const indented = selected.split('\n').map(l => '  ' + l).join('\n');
this.setRangeText(indented, start, end, 'select');
} else {
this.setRangeText('  ', start, end, 'end');
}
}
}
});
document.addEventListener('keydown', function(e) {
const isCtrl = e.ctrlKey || e.metaKey;
const key = e.key.toLowerCase();
if (searchModal.style.display === 'block') {
if (key === 'enter' && document.activeElement.id === 'find-input') {
e.preventDefault();
findNextBtn.click();
}
if (key === 'enter' && document.activeElement.id === 'replace-input') {
e.preventDefault();
replaceBtn.click();
}
return;
}
if (isCtrl && key === 's') { e.preventDefault(); saveFile(); }
if (isCtrl && key === 'o') { e.preventDefault(); openFile(); }
if (isCtrl && key === 'h') { e.preventDefault(); toggleHelp(); }
if (e.altKey && key === 'l') { e.preventDefault(); cleanEmptyLines(); }
if (e.altKey && key === 't') { e.preventDefault(); window.open(window.location.href, '_blank'); }
if (e.altKey && key === 'p') { e.preventDefault(); previewCode(); }
if (e.altKey && key === 'n') { e.preventDefault(); newFile(); }
if (e.altKey && key === 's') { e.preventDefault(); toggleSearch(); }
});
editor.addEventListener('input', () => {
if (!hasUnsavedChanges) {
hasUnsavedChanges = true;
document.title = "* " + currentFileName;
}
searchResults.term = null;
});
window.addEventListener('load', () => {
editor.focus();
syncMirrorStyles();
updateStaticUIText();
toggleHelp();
});
window.addEventListener('resize', syncMirrorStyles);
window.addEventListener('beforeunload', (e) => {
if (hasUnsavedChanges) {
e.preventDefault();
e.returnValue = '';
}
});
</script>
</body>
</html>
