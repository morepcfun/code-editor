<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Kode Editor</title>
<style>
html,
body {
margin: 0;
padding: 0;
width: 100%;
height: 100%;
background-color: #000000;
overflow: hidden;
}
textarea {
width: 100%;
height: 100%;
box-sizing: border-box;
border: none;
outline: none;
resize: none;
white-space: pre;
overflow-wrap: normal;
overflow: auto;
background-color: #000000;
color: #33FF33;
font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
font-size: 16px;
padding: 15px;
caret-color: #33FF33;
caret-shape: block;
}
.modal {
display: none;
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 400px;
background-color: #000;
border: 2px solid #33FF33;
color: #33FF33;
z-index: 100;
font-family: inherit;
padding: 20px;
box-shadow: 0 0 20px rgba(51, 255, 51, 0.3);
}
.modal h2 {
margin-top: 0;
text-align: left;
}
.modal ul {
list-style-type: none;
padding-left: 0;
}
.modal li {
margin-bottom: 10px;
}
.modal li strong {
display: inline-block;
width: 120px;
}
.modal-close-btn {
position: absolute;
top: 10px;
right: 15px;
font-size: 24px;
color: #33FF33;
cursor: pointer;
background: none;
border: none;
}
#search-modal .input-group {
margin-bottom: 15px;
}
#search-modal label {
display: block;
margin-bottom: 5px;
}
#search-modal #match-count {
float: right;
font-size: 0.8em;
color: #aaa;
line-height: 1.5;
}
#search-modal input {
width: 100%;
background-color: #111;
border: 1px solid #33FF33;
color: #33FF33;
padding: 5px;
box-sizing: border-box;
font-family: inherit;
}
#search-modal .button-group {
display: flex;
justify-content: space-between;
gap: 10px;
}
#search-modal button {
flex-grow: 1;
background: none;
border: 1px solid #33FF33;
color: #33FF33;
padding: 8px;
cursor: pointer;
transition: background-color 0.2s, color 0.2s;
}
#search-modal button:hover {
background-color: #33FF33;
color: #000;
}
</style>
</head>
<body>
<textarea id="editor" spellcheck="false" autofocus></textarea>
<div id="help-modal" class="modal">
<button id="help-modal-close-btn" class="modal-close-btn">&times;</button>
<h2 id="help-title"></h2>
<ul id="help-list"></ul>
</div>
<div id="search-modal" class="modal">
<button id="search-modal-close-btn" class="modal-close-btn">&times;</button>
<h2 id="search-title"></h2>
<div class="input-group">
<label for="find-input" id="find-label"><span id="match-count"></span></label>
<input type="text" id="find-input">
</div>
<div class="input-group">
<label for="replace-input" id="replace-label"></label>
<input type="text" id="replace-input">
</div>
<div class="button-group">
<button id="find-next-btn"></button>
<button id="replace-btn"></button>
<button id="replace-all-btn"></button>
</div>
</div>
<script>
const lang = {
    // Generelt
    title: "Kode Editor",
    untitled: "Uten tittel.txt",
    
    // Hjelp-meny
    helpTitle: "Snarveier",
    helpOpenFile: "Åpne Fil",
    helpSaveFile: "Lagre Fil",
    helpNewFile: "Ny Fil",
    helpSearchReplace: "Søk & Erstatt",
    helpToggleHelp: "Vis/Skjul Hjelp",
    helpIndent: "Innrykk (mellomrom)",
    helpOutdent: "Fjern innrykk",
    helpCleanLines: "Rydd linjer/mellomrom",
    helpNewTab: "Åpne i ny fane",
    helpPreview: "Forhåndsvis HTML",
    
    // Søk og erstatt
    searchTitle: "Søk & Erstatt",
    findLabel: "Søk:",
    replaceLabel: "Erstatt:",
    findNext: "Finn Neste",
    replace: "Erstatt",
    replaceAll: "Erstatt Alle",
    matches: "treff",
    
    // Bekreftelser og feilmeldinger
    unsavedChanges: "Du har ulagrede endringer. Er du sikker?",
    unsavedChangesLost: "Du har ulagrede endringer som vil gå tapt. Er du sikker?",
    unsupportedApi: "Nettleseren din støtter ikke moderne filsystem-API.",
    userAbortedOpen: "Brukeren avbrøt filåpning.",
    userAbortedSave: "Brukeren avbrøt lagringsdialogen.",
    saveError: "Feil: Kunne ikke lagre filen."
};

document.title = lang.title;

const editor = document.getElementById('editor');
const helpModal = document.getElementById('help-modal');
const helpModalCloseBtn = document.getElementById('help-modal-close-btn');
const searchModal = document.getElementById('search-modal');
const searchModalCloseBtn = document.getElementById('search-modal-close-btn');
const findInput = document.getElementById('find-input');
const replaceInput = document.getElementById('replace-input');
const findNextBtn = document.getElementById('find-next-btn');
const replaceBtn = document.getElementById('replace-btn');
const replaceAllBtn = document.getElementById('replace-all-btn');
const matchCountSpan = document.getElementById('match-count');
let currentFileHandle = null;
let currentFileName = lang.untitled;
let hasUnsavedChanges = false;
let searchResults = { term: '', indices: [], currentIndex: -1 };
const mirrorDiv = document.createElement('div');
document.body.appendChild(mirrorDiv);

function syncMirrorStyles() {
    const editorStyle = window.getComputedStyle(editor);
    const propertiesToCopy = [
        'fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'letterSpacing',
        'lineHeight', 'textTransform', 'wordSpacing', 'paddingTop', 'paddingRight',
        'paddingBottom', 'paddingLeft', 'borderTopWidth', 'borderRightWidth',
        'borderBottomWidth', 'borderLeftWidth', 'width', 'boxSizing',
        'whiteSpace', 'overflowWrap'
    ];
    propertiesToCopy.forEach(prop => {
        mirrorDiv.style[prop] = editorStyle[prop];
    });
    mirrorDiv.style.position = 'absolute';
    mirrorDiv.style.left = '-9999px';
    mirrorDiv.style.top = '0';
    mirrorDiv.style.height = 'auto';
    mirrorDiv.style.visibility = 'hidden';
}

async function openFile() {
    if (hasUnsavedChanges && !confirm(lang.unsavedChangesLost)) {
        return;
    }
    if ('showOpenFilePicker' in window) {
        try {
            const [fileHandle] = await window.showOpenFilePicker();
            currentFileHandle = fileHandle;
            const file = await fileHandle.getFile();
            editor.value = await file.text();
            editor.scrollTop = 0;
            editor.setSelectionRange(0, 0);
            currentFileName = file.name;
            document.title = currentFileName;
            hasUnsavedChanges = false;
        } catch (err) { console.error(lang.userAbortedOpen, err); }
    } else {
        alert(lang.unsupportedApi);
    }
}

function newFile() {
    if (hasUnsavedChanges && !confirm(lang.unsavedChanges)) {
        return;
    }
    editor.value = '';
    currentFileHandle = null;
    currentFileName = lang.untitled;
    document.title = currentFileName;
    hasUnsavedChanges = false;
    editor.focus();
}

async function saveFile() {
    if (!currentFileHandle) {
        try {
            currentFileHandle = await window.showSaveFilePicker({
                suggestedName: currentFileName,
                types: [{
                    description: 'Text/Code Files',
                    accept: {
                        'text/plain': ['.txt', '.md'],
                        'text/html': ['.html', '.htm'],
                        'text/css': ['.css'],
                        'application/javascript': ['.js']
                    },
                }],
            });
            currentFileName = currentFileHandle.name;
        } catch (err) { console.error(lang.userAbortedSave, err); return; }
    }
    try {
        const writable = await currentFileHandle.createWritable();
        await writable.write(editor.value);
        await writable.close();
        hasUnsavedChanges = false;
        document.title = currentFileName;
    } catch (err) { console.error('Failed to save file:', err); alert(lang.saveError); }
}

function previewCode() {
    const previewWindow = window.open('', '_blank');
    previewWindow.document.open();
    previewWindow.document.write(editor.value);
    previewWindow.document.close();
}

function outdentSelection() {
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    let lineStart = start;
    while (lineStart > 0 && editor.value[lineStart - 1] !== '\n') lineStart--;

    const textBefore = editor.value.substring(0, lineStart);
    let textToModify = editor.value.substring(lineStart, end);
    let removedCharsCount = 0;

    const outdentedText = textToModify.split('\n').map(line => {
        if (line.startsWith('  ')) {
            removedCharsCount += 2;
            return line.substring(2);
        } else if (line.startsWith(' ')) {
            removedCharsCount += 1;
            return line.substring(1);
        }
        return line;
    }).join('\n');

    editor.value = textBefore + outdentedText + editor.value.substring(end);

    const firstLine = textToModify.split('\n')[0];
    let firstLineRemovedChars = 0;
    if (firstLine.startsWith('  ')) {
        firstLineRemovedChars = 2;
    } else if (firstLine.startsWith(' ')) {
        firstLineRemovedChars = 1;
    }
    
    editor.selectionStart = start - firstLineRemovedChars;
    editor.selectionEnd = end - removedCharsCount;
}

function cleanEmptyLines() {
    const { selectionStart, selectionEnd } = editor;
    const isSelection = selectionStart !== selectionEnd;
    const text = isSelection ? editor.value.substring(selectionStart, selectionEnd) : editor.value;
    const cleaned = text.split('\n').map(l => l.trimEnd()).filter(l => l !== '').join('\n');
    if (isSelection) editor.setRangeText(cleaned, selectionStart, selectionEnd);
    else editor.value = cleaned;
}

function toggleHelp() {
    const isVisible = helpModal.style.display === 'block';
    helpModal.style.display = isVisible ? 'none' : 'block';
    if (isVisible) editor.focus();
}

function toggleSearch() {
    const isVisible = searchModal.style.display === 'block';
    searchModal.style.display = isVisible ? 'none' : 'block';
    if (!isVisible) {
        findInput.focus();
        findInput.select();
        updateSearchResults();
    } else {
        editor.focus();
    }
}

function updateSearchResults() {
    const searchTerm = findInput.value;
    if (searchResults.term === searchTerm && searchTerm !== '') return;
    searchResults.term = searchTerm;
    searchResults.indices = [];
    searchResults.currentIndex = -1;
    if (!searchTerm) {
        matchCountSpan.textContent = '';
        return;
    }
    let fromIndex = 0;
    while (fromIndex < editor.value.length) {
        const foundIndex = editor.value.toLowerCase().indexOf(searchTerm.toLowerCase(), fromIndex);
        if (foundIndex === -1) break;
        searchResults.indices.push(foundIndex);
        fromIndex = foundIndex + 1;
    }
    matchCountSpan.textContent = `${searchResults.indices.length} ${lang.matches}`;
}

function scrollToSelection() {
    const textBefore = editor.value.substring(0, editor.selectionStart);
    mirrorDiv.innerText = textBefore;
    const marker = document.createElement('span');
    marker.innerHTML = '&nbsp;';
    mirrorDiv.appendChild(marker);
    const selectionYPosition = marker.offsetTop;
    const targetScrollTop = selectionYPosition - (editor.clientHeight / 2);
    editor.scrollTop = Math.max(0, targetScrollTop);
}

function findNext() {
    updateSearchResults();
    if (searchResults.indices.length === 0) {
        matchCountSpan.textContent = `0 ${lang.matches}`;
        return;
    }
    searchResults.currentIndex++;
    if (searchResults.currentIndex >= searchResults.indices.length) {
        searchResults.currentIndex = 0;
    }
    const startIndex = searchResults.indices[searchResults.currentIndex];
    editor.focus();
    editor.setSelectionRange(startIndex, startIndex + searchResults.term.length);
    matchCountSpan.textContent = `${searchResults.currentIndex + 1} av ${searchResults.indices.length}`;
    scrollToSelection();
}

function replaceCurrent() {
    const searchTerm = findInput.value;
    const replaceTerm = replaceInput.value;
    const selectedText = editor.value.substring(editor.selectionStart, editor.selectionEnd);
    if (searchTerm && selectedText.toLowerCase() === searchTerm.toLowerCase()) {
        const start = editor.selectionStart;
        editor.setRangeText(replaceTerm, start, editor.selectionEnd, 'end');
        updateSearchResults();
        let searchFrom = start + replaceTerm.length;
        let nextIndex = editor.value.toLowerCase().indexOf(searchTerm.toLowerCase(), searchFrom);
        if (nextIndex !== -1) {
            searchResults.currentIndex = searchResults.indices.findIndex(i => i >= nextIndex);
            findNext();
        }
    } else {
        findNext();
    }
}

function replaceAll() {
    const searchTerm = findInput.value;
    const replaceTerm = replaceInput.value;
    if (!searchTerm) return;
    const originalScrollTop = editor.scrollTop;
    const regex = new RegExp(searchTerm, 'gi');
    editor.value = editor.value.replace(regex, replaceTerm);
    editor.scrollTop = originalScrollTop;
    updateSearchResults();
}

function updateStaticUIText() {
    document.getElementById('help-title').textContent = lang.helpTitle;
    document.getElementById('help-list').innerHTML = `
        <li><strong>Ctrl + O</strong> ${lang.helpOpenFile}</li>
        <li><strong>Ctrl + S</strong> ${lang.helpSaveFile}</li>
        <li><strong>Alt + N</strong> ${lang.helpNewFile}</li>
        <li><strong>Alt + S</strong> ${lang.helpSearchReplace}</li>
        <li><strong>Ctrl + H</strong> ${lang.helpToggleHelp}</li>
        <li><strong>Tab</strong> ${lang.helpIndent}</li>
        <li><strong>Shift + Tab</strong> ${lang.helpOutdent}</li>
        <li><strong>Alt + L</strong> ${lang.helpCleanLines}</li>
        <li><strong>Alt + T</strong> ${lang.helpNewTab}</li>
        <li><strong>Alt + P</strong> ${lang.helpPreview}</li>
    `;
    document.getElementById('search-title').textContent = lang.searchTitle;
    document.getElementById('find-label').prepend(lang.findLabel);
    document.getElementById('replace-label').textContent = lang.replaceLabel;
    document.getElementById('find-next-btn').textContent = lang.findNext;
    document.getElementById('replace-btn').textContent = lang.replace;
    document.getElementById('replace-all-btn').textContent = lang.replaceAll;
}

findInput.addEventListener('input', updateSearchResults);
helpModalCloseBtn.addEventListener('click', toggleHelp);
searchModalCloseBtn.addEventListener('click', toggleSearch);
findNextBtn.addEventListener('click', findNext);
replaceBtn.addEventListener('click', replaceCurrent);
replaceAllBtn.addEventListener('click', replaceAll);
window.addEventListener('click', (e) => { if (e.target.tagName === 'BODY') editor.focus(); });

editor.addEventListener('keydown', function(e) {
    const start = this.selectionStart;
    const end = this.selectionEnd;

    if (!e.ctrlKey && !e.altKey) {
        let closingChar = '';
        if (e.key === '(') closingChar = ')';
        else if (e.key === '{') closingChar = '}';
        else if (e.key === '[') closingChar = ']';
        else if (e.key === '/') {
            if (this.value.substring(start - 1, start) === '<') {
                const textBefore = this.value.substring(0, start - 1);
                const openTags = (textBefore.match(/<([a-zA-Z0-9]+)/g) || []).map(tag => tag.substring(1));
                const closeTags = (textBefore.match(/<\/([a-zA-Z0-9]+)>/g) || []).map(tag => tag.substring(2, tag.length - 1));
                const stack = [];
                const selfClosingTags = new Set(['br', 'hr', 'img', 'input', 'meta', 'link']);

                for (const tag of openTags) {
                    if (!selfClosingTags.has(tag)) stack.push(tag);
                }
                for (const tag of closeTags) {
                    if (stack.length > 0 && stack[stack.length - 1] === tag) stack.pop();
                }
                
                if (stack.length > 0) {
                    const tagToClose = stack.pop();
                    e.preventDefault();
                    this.setRangeText(`${tagToClose}>`, start, end, 'end');
                    return;
                }
            }
        } else if (e.key === '>') {
             const textBefore = this.value.substring(0, start);
             const tagMatch = textBefore.match(/<([a-zA-Z0-9]+)[^>]*$/);
             const selfClosingTags = new Set(['br', 'hr', 'img', 'input', 'meta', 'link']);
             if (tagMatch && !textBefore.endsWith('/') && !selfClosingTags.has(tagMatch[1])) {
                const tagName = tagMatch[1];
                const textToInsert = `></${tagName}>`;
                e.preventDefault();
                this.setRangeText(textToInsert, start, end, 'end');
                const newCursorPos = this.selectionStart - (`</${tagName}>`).length;
                this.setSelectionRange(newCursorPos, newCursorPos);
                return;
             }
        }
        
        if (closingChar) {
            e.preventDefault();
            this.setRangeText(closingChar, start, end, 'start');
        }
    }

    if (e.key === 'Tab') {
        e.preventDefault();
        if (e.shiftKey) {
            outdentSelection();
        } else {
            const selected = this.value.substring(start, end);
            if (selected.includes('\n')) {
                const indented = selected.split('\n').map(l => '  ' + l).join('\n');
                this.setRangeText(indented, start, end, 'select');
            } else {
                this.setRangeText('  ', start, end, 'end');
            }
        }
    }
});

document.addEventListener('keydown', function(e) {
    const isCtrl = e.ctrlKey || e.metaKey;
    const key = e.key.toLowerCase();
    if (searchModal.style.display === 'block') {
        if (key === 'enter' && document.activeElement.id === 'find-input') {
            e.preventDefault();
            findNextBtn.click();
        }
        if (key === 'enter' && document.activeElement.id === 'replace-input') {
            e.preventDefault();
            replaceBtn.click();
        }
        return;
    }
    if (isCtrl && key === 's') { e.preventDefault(); saveFile(); }
    if (isCtrl && key === 'o') { e.preventDefault(); openFile(); }
    if (isCtrl && key === 'h') { e.preventDefault(); toggleHelp(); }
    if (e.altKey && key === 'l') { e.preventDefault(); cleanEmptyLines(); }
    if (e.altKey && key === 't') { e.preventDefault(); window.open(window.location.href, '_blank'); }
    if (e.altKey && key === 'p') { e.preventDefault(); previewCode(); }
    if (e.altKey && key === 'n') { e.preventDefault(); newFile(); }
    if (e.altKey && key === 's') { e.preventDefault(); toggleSearch(); }
});

editor.addEventListener('input', () => {
    if (!hasUnsavedChanges) {
        hasUnsavedChanges = true;
        document.title = "* " + currentFileName;
    }
    searchResults.term = null;
});

window.addEventListener('load', () => {
    editor.focus();
    syncMirrorStyles();
    updateStaticUIText();
    toggleHelp();
});
window.addEventListener('resize', syncMirrorStyles);
window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = '';
    }
});
</script>
</body>
</html>